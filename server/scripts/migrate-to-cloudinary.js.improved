import mongoose from 'mongoose';
import fs from 'fs';
import path from 'path';
import dotenv from 'dotenv';
import { fileURLToPath } from 'url';
import Post from '../models/Post.js';
import User from '../models/User.js';
import { v2 as cloudinary } from 'cloudinary';

// Setup environment variables
dotenv.config();

// Setup paths
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const assetsDir = path.join(__dirname, '../public/assets');
const mappingFilePath = path.join(__dirname, '../data/cloudinary-mapping.json');

// Setup MongoDB connection
const connectToDatabase = async () => {
  try {
    console.log('Connecting to MongoDB...');
    await mongoose.connect(process.env.MONGO_URL, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('Connected to MongoDB');
  } catch (error) {
    console.error('MongoDB connection failed:', error);
    process.exit(1);
  }
};

// Setup Cloudinary
const setupCloudinary = () => {
  // Verify required environment variables
  if (!process.env.CLOUDINARY_CLOUD_NAME || !process.env.CLOUDINARY_API_KEY || !process.env.CLOUDINARY_API_SECRET) {
    console.error('Missing required Cloudinary environment variables. Please check your .env file.');
    process.exit(1);
  }
  
  // Configure Cloudinary
  cloudinary.config({
    cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
    api_key: process.env.CLOUDINARY_API_KEY,
    api_secret: process.env.CLOUDINARY_API_SECRET
  });
  
  return cloudinary;
};

// Load existing mapping of uploaded files
const loadCloudinaryMapping = () => {
  try {
    if (fs.existsSync(mappingFilePath)) {
      const mappingData = fs.readFileSync(mappingFilePath, 'utf8');
      return JSON.parse(mappingData);
    }
    
    // Create the directory if it doesn't exist
    const dataDir = path.dirname(mappingFilePath);
    if (!fs.existsSync(dataDir)) {
      fs.mkdirSync(dataDir, { recursive: true });
    }
    
    // Return an empty mapping
    return {};
  } catch (error) {
    console.error('Failed to load cloudinary mapping file:', error);
    return {};
  }
};

// Save mapping of uploaded files
const saveCloudinaryMapping = (mapping) => {
  try {
    fs.writeFileSync(mappingFilePath, JSON.stringify(mapping, null, 2));
    console.log(`Cloudinary mapping saved to ${mappingFilePath}`);
  } catch (error) {
    console.error('Failed to save cloudinary mapping file:', error);
  }
};

// Upload file to Cloudinary
const uploadToCloudinary = async (filePath, fileName, mapping) => {
  // If the file is already in the mapping, skip upload
  if (mapping[fileName]) {
    console.log(`File ${fileName} already uploaded to Cloudinary. URL: ${mapping[fileName]}`);
    return mapping[fileName];
  }
  
  try {
    console.log(`Uploading ${fileName} to Cloudinary...`);
    
    // The 'resource_type' parameter is important for proper handling of different file types
    let resourceType = 'auto';
    
    // Determine if we need to force a specific resource type based on file extension
    const ext = path.extname(fileName).toLowerCase();
    if (['.mp3', '.ogg', '.wav', '.m4a'].includes(ext)) {
      resourceType = 'video'; // Cloudinary uses 'video' resource type for audio files too
    }
    
    const result = await cloudinary.uploader.upload(filePath, {
      public_id: `mern-social/${path.basename(fileName, ext)}`,
      folder: 'mern-social',
      resource_type: resourceType,
      use_filename: true,
      unique_filename: true
    });
    
    // Store the mapping
    mapping[fileName] = result.secure_url;
    
    console.log(`Upload successful. URL: ${result.secure_url}`);
    return result.secure_url;
  } catch (error) {
    console.error(`Failed to upload ${fileName}:`, error);
    return null;
  }
};

// Update database references
const updateDatabase = async (oldFileName, newUrl) => {
  try {
    // Update user profile pictures
    const usersUpdated = await User.updateMany(
      { picturePath: oldFileName },
      { $set: { picturePath: newUrl } }
    );
    
    // Update post picture paths
    const postsUpdated = await Post.updateMany(
      { picturePath: oldFileName },
      { $set: { picturePath: newUrl } }
    );
    
    // Update post audio paths
    const audioUpdated = await Post.updateMany(
      { audioPath: oldFileName },
      { $set: { audioPath: newUrl } }
    );
    
    // Update posts with this file in mediaPaths array
    const mediaPathsUpdated = await Post.updateMany(
      { mediaPaths: oldFileName },
      { $pull: { mediaPaths: oldFileName } }
    );
    
    if (mediaPathsUpdated.modifiedCount > 0) {
      await Post.updateMany(
        { "mediaPaths": { $ne: newUrl } },
        { $push: { mediaPaths: newUrl } }
      );
    }
    
    // Update user pictures in comments
    const commentsUpdated = await Post.updateMany(
      { "comments.userPicturePath": oldFileName },
      { $set: { "comments.$[elem].userPicturePath": newUrl } },
      { arrayFilters: [{ "elem.userPicturePath": oldFileName }] }
    );
    
    console.log(`Database updates for ${oldFileName} -> ${newUrl}:`);
    console.log(`- Users updated: ${usersUpdated.modifiedCount}`);
    console.log(`- Posts updated (picturePath): ${postsUpdated.modifiedCount}`);
    console.log(`- Posts updated (audioPath): ${audioUpdated.modifiedCount}`);
    console.log(`- Posts updated (mediaPaths): ${mediaPathsUpdated.modifiedCount}`);
    console.log(`- Comments updated: ${commentsUpdated.modifiedCount}`);
    
    return usersUpdated.modifiedCount + postsUpdated.modifiedCount + 
           audioUpdated.modifiedCount + mediaPathsUpdated.modifiedCount +
           commentsUpdated.modifiedCount;
  } catch (error) {
    console.error(`Failed to update database for ${oldFileName}:`, error);
    return 0;
  }
};

// Check if database references already point to Cloudinary
const checkDatabaseReferences = async (fileName) => {
  try {
    // Count references to the local file name
    const userCount = await User.countDocuments({ picturePath: fileName });
    const postPictureCount = await Post.countDocuments({ picturePath: fileName });
    const postAudioCount = await Post.countDocuments({ audioPath: fileName });
    const postMediaCount = await Post.countDocuments({ mediaPaths: fileName });
    
    // If there are no references to the local file name, it might be already migrated
    return userCount + postPictureCount + postAudioCount + postMediaCount === 0;
  } catch (error) {
    console.error(`Failed to check database references for ${fileName}:`, error);
    return false;
  }
};

// Main migration function
const migrateToCloudinary = async () => {
  try {
    // Connect to the database
    await connectToDatabase();
    
    // Setup Cloudinary
    setupCloudinary();
    
    // Load existing mapping
    const mapping = loadCloudinaryMapping();
    console.log(`Loaded ${Object.keys(mapping).length} previously migrated files`);
    
    // Verify the assets directory exists
    if (!fs.existsSync(assetsDir)) {
      console.error(`Assets directory not found: ${assetsDir}`);
      process.exit(1);
    }
    
    // Get all files in the assets directory
    const files = fs.readdirSync(assetsDir);
    console.log(`Found ${files.length} files in the assets directory`);
    
    // Track statistics
    let totalFiles = files.length;
    let alreadyMigrated = 0;
    let successfulUploads = 0;
    let failedUploads = 0;
    let databaseUpdates = 0;
    let skippedFiles = 0;
    
    // Process each file
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const filePath = path.join(assetsDir, file);
      const stats = fs.statSync(filePath);
      
      // Skip directories
      if (!stats.isFile()) {
        console.log(`Skipping directory: ${file}`);
        totalFiles--;
        continue;
      }
      
      console.log(`[${i+1}/${files.length}] Processing ${file}...`);
      
      // Check if the file is already in the mapping
      if (mapping[file]) {
        console.log(`File ${file} has been previously migrated to ${mapping[file]}`);
        
        // Check if we still need to update database references
        const alreadyUpdated = await checkDatabaseReferences(file);
        
        if (alreadyUpdated) {
          console.log(`Database references for ${file} are already updated. Skipping...`);
          alreadyMigrated++;
          continue;
        } else {
          // Update database references to use the Cloudinary URL
          console.log(`Updating database references for ${file} to use ${mapping[file]}...`);
          const updates = await updateDatabase(file, mapping[file]);
          databaseUpdates += updates;
        }
      } else {
        // Upload to Cloudinary
        const cloudUrl = await uploadToCloudinary(filePath, file, mapping);
        
        if (cloudUrl) {
          // Update database references
          const updates = await updateDatabase(file, cloudUrl);
          databaseUpdates += updates;
          successfulUploads++;
          
          // Save mapping periodically
          if (i % 10 === 0 || i === files.length - 1) {
            saveCloudinaryMapping(mapping);
          }
        } else {
          failedUploads++;
          console.error(`Failed to upload ${file} to Cloudinary`);
        }
      }
    }
    
    // Save final mapping
    saveCloudinaryMapping(mapping);
    
    // Print summary
    console.log('\n=== Migration Summary ===');
    console.log(`Total files in assets directory: ${totalFiles}`);
    console.log(`Already migrated files: ${alreadyMigrated}`);
    console.log(`Newly uploaded files: ${successfulUploads}`);
    console.log(`Failed uploads: ${failedUploads}`);
    console.log(`Database references updated: ${databaseUpdates}`);
    console.log(`Total files tracked in mapping: ${Object.keys(mapping).length}`);
    
    if (failedUploads === 0) {
      console.log('\n✅ Migration completed successfully!');
    } else {
      console.log('\n⚠️ Migration completed with some issues.');
    }
  } catch (error) {
    console.error('Migration failed:', error);
  } finally {
    try {
      await mongoose.connection.close();
      console.log('MongoDB connection closed.');
    } catch (err) {
      console.error('Error closing MongoDB connection:', err);
    }
  }
};

// Run the migration
migrateToCloudinary();